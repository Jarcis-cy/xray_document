xray 基于 Go 编写，在 Go 语言中用户层级里没有线程的概念，但拥有一个比线程更加
强劲，更加好用的并发模型 —— Goroutine。这里的并发也基本指代的是同时在进行漏洞扫描的 Goroutine 的数量。

看起来有些拗口，我们可以用更简单的方式来理解这个概念。假设一个请求在整个扫描流程中需要被 100 个插件扫描且每个插件的执行时间为1秒钟，
倘若我们设置了并发为 50，那么只需要 2s 就能执行完所有的插件；如果设置并发为 20，那么就需要 5s 才能执行完所有插件。实际上，xray 在插件执行层面就是我们在操作系统中学习到的“生产者消费者模型”。

在配置文件中可以用下面的配置改变漏洞探测的 worker 数量:

```
parallel: 30                      # 漏洞探测的 worker 数量，可以简单理解为同时有 30 个 POC 在运行
```

指的一提的是，这个值并非越大越好，因为高并发的情况下多个 worker 之间会互相竞争资源，形成所谓的内卷，最终八面俱伤，不仅没有扫到漏洞
还可能把目标机器扫挂。至于设置多少，这个需要综合考量运行 xray 的机器的性能、当前机器与目标机器之间带宽的大小以及目标机器的性能，xray 默认的 30 是一个相对保守的数值，
但大多数情况都足够了。